{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Background Operation ID is a ministry that exists to serve the need of individuals who need to obtain identification documents to support their application for a variety of services from housing to job application. The ministry is volunteer driven and has been in place for over thirty years. During this time thousands of individuals have received help to support their identification needs. Help is provided in the form of vouchers that can be used to pay for services rendered by either the Texas Department of Public Safety for a Texas ID or by the Bureau of Vital Statistics of Texas or another state to acquire a certified copy of a birth certificate. Operation ID makes every attempt to be a good steward of the limited resources available to it. To this end Operation ID seeks to enforce a twice-in-a-lifetime policy with respect to the vouchers it issues. A client of Operation ID is limited to 2 IDs or 2 birth certificates in a lifetime. The 2 IDs restriction applies to Texas state IDs or Texas Drivers licenses or one of each. Users OPIDChecks is a role-based system. Each registered user will be assigned a user role by the OPIDChecks administrator. The role that a user is assigned will determine the OPIDChecks features available to the user. The OPIDChecks administrator will be in the role of Superadmin and will have access to features necessary for the maintenance of application OPIDChecks. There will be only one Superadmin account, but the credentials for this account will be available to maintainers of the application. MkDocs This document was created using MkDocs as was the MkDocs website itself. MkDocs was installed following the guide on this page . This guide is useful for setting up the environment; however, the syntax for the file mkdocs.yml has changed from that described in the guide. The new syntax can be found at in the User Guide section of this document . An MkDocs document is a static website and can hosted by any service that supports static sites. This MkDocs document is hosted by GitHub Pages . The Atom open source text editor was used to develop the document on the desktop. An MkDocs document uses HTML Markdown for a desktop development version of a document. GitHub provides a cheatsheet for Markdown syntax . MkDocs provides a built-in preview server. To start this server, open a BASH Shell on the folder containing the mkdoc.yml file of the project and execute mkdocs serve Then go to http://127.0.0.1:8000 in a desktop browser. Pages can be edited and saved while in preview mode. The changes will be reflected in the browser document. When it is time to publish a version of a document, in a Git BASH shell opened on the folder containing the mkdocs.yml file, issue the command mkdocs build to expand the Markdown version of the document into an HTML version in the /site folder. Then open the Git GUI on the folder containing the mkdocs.yml file and use the GUI to create a new Git repository on the local disk. Next create repository opidchecksdoc to hold the documentation at GitHub. After this, in the folder containing the mkdocs.yml file, define a remote called origin for the document: git remote add origin https://github.com/tmhsplb/opidchecksdoc This command references the GitHub repository opidchecksdoc. The remote only needs to be defined once. It will be remembered by the Git BASH shell. In the shell issue the following commands: git add -A git commit -a -m 'Initial commit' git push origin master This will push the master branch of the document to the repository identified by the remote called origin. Then click on the Settings tab for the newly created repository and scroll down to the GitHub Pages section. Select the master branch source and click on the Save button. Finally, to view the published document go to: https://tmhsplb.github.io/opiddailydoc/site Unless a new file is added to file mkdocs.yml , subsequent edits only require the commands mkdocs build git commit -a -m '<Comment for new commit>' git push origin master to update repository opiddailydoc at GitHub. If a new file is added to mkdocs.yml then git add -A must be run before the mkdocs build command is run. This causes any new files to be added to the local git repository. In either case it may take several minutes before edits are available.","title":"Background"},{"location":"#background","text":"Operation ID is a ministry that exists to serve the need of individuals who need to obtain identification documents to support their application for a variety of services from housing to job application. The ministry is volunteer driven and has been in place for over thirty years. During this time thousands of individuals have received help to support their identification needs. Help is provided in the form of vouchers that can be used to pay for services rendered by either the Texas Department of Public Safety for a Texas ID or by the Bureau of Vital Statistics of Texas or another state to acquire a certified copy of a birth certificate. Operation ID makes every attempt to be a good steward of the limited resources available to it. To this end Operation ID seeks to enforce a twice-in-a-lifetime policy with respect to the vouchers it issues. A client of Operation ID is limited to 2 IDs or 2 birth certificates in a lifetime. The 2 IDs restriction applies to Texas state IDs or Texas Drivers licenses or one of each.","title":"Background"},{"location":"#users","text":"OPIDChecks is a role-based system. Each registered user will be assigned a user role by the OPIDChecks administrator. The role that a user is assigned will determine the OPIDChecks features available to the user. The OPIDChecks administrator will be in the role of Superadmin and will have access to features necessary for the maintenance of application OPIDChecks. There will be only one Superadmin account, but the credentials for this account will be available to maintainers of the application.","title":"Users"},{"location":"#mkdocs","text":"This document was created using MkDocs as was the MkDocs website itself. MkDocs was installed following the guide on this page . This guide is useful for setting up the environment; however, the syntax for the file mkdocs.yml has changed from that described in the guide. The new syntax can be found at in the User Guide section of this document . An MkDocs document is a static website and can hosted by any service that supports static sites. This MkDocs document is hosted by GitHub Pages . The Atom open source text editor was used to develop the document on the desktop. An MkDocs document uses HTML Markdown for a desktop development version of a document. GitHub provides a cheatsheet for Markdown syntax . MkDocs provides a built-in preview server. To start this server, open a BASH Shell on the folder containing the mkdoc.yml file of the project and execute mkdocs serve Then go to http://127.0.0.1:8000 in a desktop browser. Pages can be edited and saved while in preview mode. The changes will be reflected in the browser document. When it is time to publish a version of a document, in a Git BASH shell opened on the folder containing the mkdocs.yml file, issue the command mkdocs build to expand the Markdown version of the document into an HTML version in the /site folder. Then open the Git GUI on the folder containing the mkdocs.yml file and use the GUI to create a new Git repository on the local disk. Next create repository opidchecksdoc to hold the documentation at GitHub. After this, in the folder containing the mkdocs.yml file, define a remote called origin for the document: git remote add origin https://github.com/tmhsplb/opidchecksdoc This command references the GitHub repository opidchecksdoc. The remote only needs to be defined once. It will be remembered by the Git BASH shell. In the shell issue the following commands: git add -A git commit -a -m 'Initial commit' git push origin master This will push the master branch of the document to the repository identified by the remote called origin. Then click on the Settings tab for the newly created repository and scroll down to the GitHub Pages section. Select the master branch source and click on the Save button. Finally, to view the published document go to: https://tmhsplb.github.io/opiddailydoc/site Unless a new file is added to file mkdocs.yml , subsequent edits only require the commands mkdocs build git commit -a -m '<Comment for new commit>' git push origin master to update repository opiddailydoc at GitHub. If a new file is added to mkdocs.yml then git add -A must be run before the mkdocs build command is run. This causes any new files to be added to the local git repository. In either case it may take several minutes before edits are available.","title":"MkDocs"},{"location":"Database/","text":"Database OPIDDaily is a database driven application built using SQL Server technology. In the desktop environment OPIDDaily is built using the Sql Server Express database engine. In the online environment at AppHarbor a full SQL Server is used. The two versions are compatible with each other with respect to the database features used. SQL Server Management Studio v18.0 (SSMS) is used to manage both database engines. In the desktop environment, Windows Authentication is used to connect to the Sql Server Express database. In the online enviroment, SQL Server Authentication is used to connect to the SQL Server database. When application OPIDDaily was created at AppHarbor, a free version of SQL Server was added on through the AppHarbor interface. The connection string to this SQL Server is found by selecting the SQL Server add-on and following the \"Go to SQL Server\" link on the page that appears. The value of this connection string is stored as the value of Config.WorkingProductionConnection string on file Config.cs. The 3 components of the connection string, HostName, UserName and Password, are also displayed on this page. The components may be used to configure a SQL Server Authentication connection to the AppHarbor database through SSMS. The same connection string displayed at AppHarbor is retrieved at runtime by accessing Config.ConnectionString, which returns the value of SQLSERVER_CONNNECTION_STRING configured in the <appSettings> section of file Web.config. The statically configured value on file Web.Config points to the OpidDailyDB on the desktop SQL Server Express. At runtime, AppHarbor will overwrite this statically configured value with the value displayed at AppHarbor. See the section on the Connection String on this tab. Connection String In the desktop environment, SSMS was used to create an empty project database by executing the SQL query create database OpidDailyDB The Visual Studio Server Explorer (found under the OPIDDaily project View menu) was then used to discover the connection string to database OpidDailyDB by creating a new Data Connection to it and copying the Connection String property of the data connection as the value of the variable SQLSERVER_CONNECTION_STRING in the <appSettings> section of Web.config. The value is accessed on files IDentityDB.cs and OpidDailyDB.cs by reading the value of the static variable Config.ConnectionString. The online version of OPIDDaily is hosted as an application at AppHarbor and it uses a database server provided as an add-on. The add-on database server includes a database which serves as the application database, so it is not necessary to create the application database as was done above for the desktop version. ELMAH uses the configuration string used by the OPIDDaily application. This is accomplished by configuring the connection string OpidDailyConnectionString in the <connectionStrings> section on Web.config and setting the connection string alias for the SQL Server add-on at AppHarbor to be OpidDailyConnectionString . To set this alias, select the SQL Server add-on for application OPIDDaily at AppHarbor and then follow the link \"Go to SQL Server\" on the page that appears. Click the button labeled \"Edit database configuration\" to set OpidDailyConnectionString as the alias value for the connection string. When this is done, OpidDailyConnectionString will appear as the value of SQLSERVER_CONNECTION_STRING_ALIAS in the Configuration variables section of application OPIDDaily at AppHarbor. When application OPIDDaily is deployed to AppHarbor, this alias will overwrite the configured value on file Web.config by the value of the connection string for the AppHarbor database. This is explained in the same knowledge base article referenced above. Database Diagram The diagram was created by SSMS, copied to the clipboard (using the \"Copy Diagram to Clipboard\" command found on the freespace context menu) and then pasted into the Paint tool. Inside of Paint it is saved as a .PNG file. Version 18.0 of SSMS does not allow database diagrams to be created. Newer releases have restored this capability. But the diagram seen here was created by an earlier release of SSMS, which did have the ability to create database diagrams. The 3 tables in the upper left of the above diagram are created by ASP.NET Identity 2.0 to manage registered users of OPIDDaily. The 3 tables are managed by their own data context which cannot be augmented by additional tables. However, data fields can be added to table AspNetUsers if necessary. The data field AgencyId was added to table AspNetUsers to store the unique AgencyId stored in table Agencies by the Superadmin user. (The AgencyId of an Operation ID user - example the TicketMaster user - is always 0.) Non ASP.NET Identity tables in the diagram are managed by a separate data context. The 2 data contexts of project OPIDDaily are referred to as IdentityDb and OpidDailyDB. (See the section Entity Framework Code First of the Infrastructure tab.) The technique for establishing a single connection string over 2 data contexts is described in Scott Allen's Pluralsight video . The tables belonging to data context OpidDailyDB were created at AppHarbor using a script file. This was done by running the command PM> update-database -ConfigurationTypeName OPIDDaily.DataContexts.OPIDDailyMigrations.Configuration -Script -SourceMigration $InitialDatabase to generate a SQL script to be run in SSMS against the database at AppHarbor. The command created a script file necessary to create the tables for this data context using all the migrations applied since the initial migration. Notice that there is no colon (:) following -SourceMigration in this command. To generate a script to run the Down methods of multiple down-migrations, do, for example, PM> Update-Database -ConfigurationTypeName OPIDDAILY.DataContexts.OpidDailyMigrations.Configuration -Script -TargetMigration: ExpressClient Notice that there is a colon (:) following -TargetMigration in this command. This command will create a script to run the Down methods of all migrations since (and not including) migration ExpressClient. It is important to be able to generate this script if changes need to be backed out, because the deployed versions of application OPIDDaily do not use Entity Framework to manage the database. Managing Users OPIDDaily is a role based database application administered by a Superadmin user. The Superadmin user has the responsibilty of establishing a login account for each OPIDDaily user, which includes the use's role. This is done prevent a user from specifying his/her own role when logging in and to force the user into his/her assigned role instead. See the introduction and Role Controllers sections of the Impementation tab for a discussion of roles. The Superadmin will be given a user name and email address for a new user. For example, if Mary Atwood would like to use the user name Mary and email address maryatwood@gmail.com, this request would be given to the Superadmin user. Provided that the user name Mary is not already in use, the Superadmin user would use a private interface to enter Mary Atwood in the Invitations table under UserName Mary (with FullName Mary Atwood) and Email Address maryatwood@gmail.com. The Supeadmin would also use the OPIDDaily interface to assign a role to user Mary Atwood in the Invitations table. The record in the Invitations table is in effect an invitation for Mary Atwood to register under user name Mary and email address maryatwood@gmail.com in the assigned role. The Superadmin will notify Mary that her account has been created and that she may register with application OPIDDaily using the credentials she has supplied together with a password of her own choosing. When Mary registers, the user name and email address she provides will be checked against the Invitations table. If this pair of credentials is not found in the Invitations table, Mary's attempt to register will be rejected. If they are found, a record will be created for her in the AspNetUsers table using the password she has specified and using the role assigned by the Superadmin, which has been stored in the Invitations table. On subsequent visits to OPIDDaily, Mary may simply login with the credentials established by her registration. When logged in she will be recognized in her assigned role. User email addresses do not need to be unique per account. This is not the default behavior; it is enabled by the setting RequireUniqueEmail = false in method ApplicationUserManager.Create on file App_Start/IdentityConfig.cs There are two special accounts reserved for usage by the two users who serve at the front desk on any given day of operation. Each of these accounts has the pre-assigned role called FrontDesk. The users are the Screener and the TicketMaster which correspond to the pipeline stages Screening and Checkin , respectively. (See the Background tab for information about the pipeline stages.) Having dedicated accounts avoids the need to create unique accounts in the role of FrontDesk. There are also two additional special users called Client1 and Client2 corresponding to the pipeline stages Screening and CheckIn , respectively. (See the Background tab for information about the pipeline stages.) During the screening stage, the Screener user will enter the name and date of birth of an entering client into the OPIDDaily database. To ensure that this information has been correctly entered, the Screener may click a button to have this information appear on a small tablet computer which will be handed to the client for verification. This small tablet computer will be logged into the OPIDDaily application as Client1 . During the Checkin stage, by consultng the Apricot database, the TicketMaster user will record any previous visit history by a screened client in the OPIDDaily database. If previous visits indicate that the screened client is ineligible for a service being sought, the TicketMaser may click a button to have the visit history appear on a second small tablet computer which will be handed to the client. This second small tablet computer will be logged into the OPIDDaily application as Client2 . Both users Client1 and Client2 are assigned the role FrontDesk. Database Utilization SSMS can be used to check on the utilization of a datbase. To do so: Right click a database name Navigate to Reports > Standard Reports > Disk Usage This is important because of the 20MB disk space limit of a free AppHarbor database. Use it to make sure the disk limits are not exceeded. Application OPIDDaily allows the Superadmin user to delete client datbase records corresponding to previous days of operation. This must be done periodically to avoid exceeding the 20MB limit.","title":"Database"},{"location":"Database/#database","text":"OPIDDaily is a database driven application built using SQL Server technology. In the desktop environment OPIDDaily is built using the Sql Server Express database engine. In the online environment at AppHarbor a full SQL Server is used. The two versions are compatible with each other with respect to the database features used. SQL Server Management Studio v18.0 (SSMS) is used to manage both database engines. In the desktop environment, Windows Authentication is used to connect to the Sql Server Express database. In the online enviroment, SQL Server Authentication is used to connect to the SQL Server database. When application OPIDDaily was created at AppHarbor, a free version of SQL Server was added on through the AppHarbor interface. The connection string to this SQL Server is found by selecting the SQL Server add-on and following the \"Go to SQL Server\" link on the page that appears. The value of this connection string is stored as the value of Config.WorkingProductionConnection string on file Config.cs. The 3 components of the connection string, HostName, UserName and Password, are also displayed on this page. The components may be used to configure a SQL Server Authentication connection to the AppHarbor database through SSMS. The same connection string displayed at AppHarbor is retrieved at runtime by accessing Config.ConnectionString, which returns the value of SQLSERVER_CONNNECTION_STRING configured in the <appSettings> section of file Web.config. The statically configured value on file Web.Config points to the OpidDailyDB on the desktop SQL Server Express. At runtime, AppHarbor will overwrite this statically configured value with the value displayed at AppHarbor. See the section on the Connection String on this tab.","title":"Database"},{"location":"Database/#connection-string","text":"In the desktop environment, SSMS was used to create an empty project database by executing the SQL query create database OpidDailyDB The Visual Studio Server Explorer (found under the OPIDDaily project View menu) was then used to discover the connection string to database OpidDailyDB by creating a new Data Connection to it and copying the Connection String property of the data connection as the value of the variable SQLSERVER_CONNECTION_STRING in the <appSettings> section of Web.config. The value is accessed on files IDentityDB.cs and OpidDailyDB.cs by reading the value of the static variable Config.ConnectionString. The online version of OPIDDaily is hosted as an application at AppHarbor and it uses a database server provided as an add-on. The add-on database server includes a database which serves as the application database, so it is not necessary to create the application database as was done above for the desktop version. ELMAH uses the configuration string used by the OPIDDaily application. This is accomplished by configuring the connection string OpidDailyConnectionString in the <connectionStrings> section on Web.config and setting the connection string alias for the SQL Server add-on at AppHarbor to be OpidDailyConnectionString . To set this alias, select the SQL Server add-on for application OPIDDaily at AppHarbor and then follow the link \"Go to SQL Server\" on the page that appears. Click the button labeled \"Edit database configuration\" to set OpidDailyConnectionString as the alias value for the connection string. When this is done, OpidDailyConnectionString will appear as the value of SQLSERVER_CONNECTION_STRING_ALIAS in the Configuration variables section of application OPIDDaily at AppHarbor. When application OPIDDaily is deployed to AppHarbor, this alias will overwrite the configured value on file Web.config by the value of the connection string for the AppHarbor database. This is explained in the same knowledge base article referenced above.","title":"Connection String"},{"location":"Database/#database-diagram","text":"The diagram was created by SSMS, copied to the clipboard (using the \"Copy Diagram to Clipboard\" command found on the freespace context menu) and then pasted into the Paint tool. Inside of Paint it is saved as a .PNG file. Version 18.0 of SSMS does not allow database diagrams to be created. Newer releases have restored this capability. But the diagram seen here was created by an earlier release of SSMS, which did have the ability to create database diagrams. The 3 tables in the upper left of the above diagram are created by ASP.NET Identity 2.0 to manage registered users of OPIDDaily. The 3 tables are managed by their own data context which cannot be augmented by additional tables. However, data fields can be added to table AspNetUsers if necessary. The data field AgencyId was added to table AspNetUsers to store the unique AgencyId stored in table Agencies by the Superadmin user. (The AgencyId of an Operation ID user - example the TicketMaster user - is always 0.) Non ASP.NET Identity tables in the diagram are managed by a separate data context. The 2 data contexts of project OPIDDaily are referred to as IdentityDb and OpidDailyDB. (See the section Entity Framework Code First of the Infrastructure tab.) The technique for establishing a single connection string over 2 data contexts is described in Scott Allen's Pluralsight video . The tables belonging to data context OpidDailyDB were created at AppHarbor using a script file. This was done by running the command PM> update-database -ConfigurationTypeName OPIDDaily.DataContexts.OPIDDailyMigrations.Configuration -Script -SourceMigration $InitialDatabase to generate a SQL script to be run in SSMS against the database at AppHarbor. The command created a script file necessary to create the tables for this data context using all the migrations applied since the initial migration. Notice that there is no colon (:) following -SourceMigration in this command. To generate a script to run the Down methods of multiple down-migrations, do, for example, PM> Update-Database -ConfigurationTypeName OPIDDAILY.DataContexts.OpidDailyMigrations.Configuration -Script -TargetMigration: ExpressClient Notice that there is a colon (:) following -TargetMigration in this command. This command will create a script to run the Down methods of all migrations since (and not including) migration ExpressClient. It is important to be able to generate this script if changes need to be backed out, because the deployed versions of application OPIDDaily do not use Entity Framework to manage the database.","title":"Database Diagram"},{"location":"Database/#managing-users","text":"OPIDDaily is a role based database application administered by a Superadmin user. The Superadmin user has the responsibilty of establishing a login account for each OPIDDaily user, which includes the use's role. This is done prevent a user from specifying his/her own role when logging in and to force the user into his/her assigned role instead. See the introduction and Role Controllers sections of the Impementation tab for a discussion of roles. The Superadmin will be given a user name and email address for a new user. For example, if Mary Atwood would like to use the user name Mary and email address maryatwood@gmail.com, this request would be given to the Superadmin user. Provided that the user name Mary is not already in use, the Superadmin user would use a private interface to enter Mary Atwood in the Invitations table under UserName Mary (with FullName Mary Atwood) and Email Address maryatwood@gmail.com. The Supeadmin would also use the OPIDDaily interface to assign a role to user Mary Atwood in the Invitations table. The record in the Invitations table is in effect an invitation for Mary Atwood to register under user name Mary and email address maryatwood@gmail.com in the assigned role. The Superadmin will notify Mary that her account has been created and that she may register with application OPIDDaily using the credentials she has supplied together with a password of her own choosing. When Mary registers, the user name and email address she provides will be checked against the Invitations table. If this pair of credentials is not found in the Invitations table, Mary's attempt to register will be rejected. If they are found, a record will be created for her in the AspNetUsers table using the password she has specified and using the role assigned by the Superadmin, which has been stored in the Invitations table. On subsequent visits to OPIDDaily, Mary may simply login with the credentials established by her registration. When logged in she will be recognized in her assigned role. User email addresses do not need to be unique per account. This is not the default behavior; it is enabled by the setting RequireUniqueEmail = false in method ApplicationUserManager.Create on file App_Start/IdentityConfig.cs There are two special accounts reserved for usage by the two users who serve at the front desk on any given day of operation. Each of these accounts has the pre-assigned role called FrontDesk. The users are the Screener and the TicketMaster which correspond to the pipeline stages Screening and Checkin , respectively. (See the Background tab for information about the pipeline stages.) Having dedicated accounts avoids the need to create unique accounts in the role of FrontDesk. There are also two additional special users called Client1 and Client2 corresponding to the pipeline stages Screening and CheckIn , respectively. (See the Background tab for information about the pipeline stages.) During the screening stage, the Screener user will enter the name and date of birth of an entering client into the OPIDDaily database. To ensure that this information has been correctly entered, the Screener may click a button to have this information appear on a small tablet computer which will be handed to the client for verification. This small tablet computer will be logged into the OPIDDaily application as Client1 . During the Checkin stage, by consultng the Apricot database, the TicketMaster user will record any previous visit history by a screened client in the OPIDDaily database. If previous visits indicate that the screened client is ineligible for a service being sought, the TicketMaser may click a button to have the visit history appear on a second small tablet computer which will be handed to the client. This second small tablet computer will be logged into the OPIDDaily application as Client2 . Both users Client1 and Client2 are assigned the role FrontDesk.","title":"Managing Users"},{"location":"Database/#database-utilization","text":"SSMS can be used to check on the utilization of a datbase. To do so: Right click a database name Navigate to Reports > Standard Reports > Disk Usage This is important because of the 20MB disk space limit of a free AppHarbor database. Use it to make sure the disk limits are not exceeded. Application OPIDDaily allows the Superadmin user to delete client datbase records corresponding to previous days of operation. This must be done periodically to avoid exceeding the 20MB limit.","title":"Database Utilization"},{"location":"Implementation/","text":"Implementation Application OPIDDaily is implemented as an ASP.NET Framework application using the ASP.NET MVC 5 project template provided by Visual Studio 2019 (Community Edition). It uses ASP.NET Identity 2.0 to define a set of user roles. Each user role is associated with a separate MVC controller. Controller inheritance is used to share editing functionality across user roles. It may be useful to upgrade application OPIDDaily to use the more modern ASP.NET Core technology. It may also be useful to proivde an alternative to the free hosting service AppHarbor, which is currentl used by OPIDDaily. See the AppHarbor section of the Infratructure tab for details on this. The graphical user interface of OPIDDaily is built using Bootstrap 3.0.0. Each user role is associated with its own layout file which defines a Bootstrap navbar containing links to the OPIDDaily features available to users in the role. The ASP.NET Identity system ensures that a user in a specified role cannot visit any pages outside of those allowed to users in that role. (See the section on Role Controllers.) Because of its use of SignalR, application OPIDDaily will always require a server side component. See the section on SignalR on this tab for a discussion of this. The Superadmin User OPIDDaily defines a pre-registered Superadmin user who has privileges to create new roles invite new users to register in a pre-determined role add new agencies The credentials for the Superadmin user are configured on file Startup.cs. There is only a single user with role of Superadmin. MVC Routing Application OPIDDaily uses only the default routing rule supplied by the Visual Studio MVC 5 template. This default routing rule is found in .../App_Start/RoutConfig.cs . routes.MapRoute( name: \"Default\", url: \"{controller}/{action}/{id}\", defaults: new { controller = \"Users\", action = \"Index\", id = UrlParameter.Optional } ); For the sake of simplicity, future development of application OPIDDaily should strive to keep this as the one and only routing rule. Role Controllers There is an MVC controller defined for each role defined by the superadmin user. Each controller defined for a role inherits from SharedController to implement shared funtionality. The role controllers manage the views of application OPIDDaily. The implementation of each role controller defines methods that are accessible through the menubar defined on the layout file for the role. For example, the FrontDeskController - which implements the FrontDesk role - contains methods ExpressClient and ExistingClient (found on the SharedController) invoked from the menubar defined on file ~/Shared/_FrontDesk.cshtml. This is the layout file for the FrontDesk role. Each view returned by the FrontDeskController includes this layout file, thereby ensuring that a user in the role of FrontDesk will only invoke methods defined by the FrontDeskController. Each other role controllers is implemented the same way: each has a defined layout file that is included in each view returned by the controller. The layout file defines a menubar that specifies the methods that users in the role can invoke. As protection against unauthorized access to methods of a role controller, use of each role controller is limited to users in the role associated with the controller. For example, the FrontDeskController is protected by the annotation [Authorize(Roles = \"FrontDesk\")] Access is then restricted by the functionality of ASP.NET Identity to authenticated users in role FrontDesk. The SharedController Each role controller derives from SharedController. The SharedController implements the shared editor functionality available to the different roles. Deriving role controllers from a shared controller is an extremely useful technique for building a role-based editor. The UsersController The UsersController controls access to the ASP.NET Identity tables used to store registered users and the roles they are in. The method UsersController.Index is the entry point for an authenticated user. The role an authenticated user is in determines the method the user will be redirected to from this entry point. jqGrid The entire implementation of application OPIDDaily is structured around instances of jqGrid appearing in MVC Views. Each jqGrid is initially populated by a call to an MVC action made through the url property of the grid. For example, the clientsGrid on view FrontDesk/Clients.cshtml is initially populated by the call \"@Url.Action(\"GetClients\", \"FrontDesk)\" which is the value of the url argument to grid clientsGrid. (Method GetClients is found on the SharedController.) Each instance of a jqGride defines a pager , which defines the CRUD operations supported by the grid. Each CRUD operation is implemented by an MVC action of the role controller associated with the grid. Initial population of a grid, grid pagination, grid searching and grid CRUD operations are all supported by server side code. There is a collection of jqGrid Demos that was very helpful during the development of OPIDDaily. NowServing An important concept in the implementation of OPIDDaily is the concept of the client currently being served by a registered OPIDDaily user. For example, when a row in the clientsGrid defined on FrontDeskClients.cshtml is selected, the JavaScript function that is the value of the onSelectRow property of the grid is invoked. When the function is invoked, the value passed to its nowServing argument is the id associated with the client represented by the selected row. The function posts to the server side method NowServing of the FrontDeskController (found on SharedController) via the code Url.Action(\"NowServing\", \"FrontDesk\") passing the JavaScript variable nowServing in the post as a result of the line postData: { nowServing: nowServing } Method SharedController/NowServing has an optional argument called nowServing. MVC data binding will cause this variable to be bound to the JavaScript variable in the post. The AgencyId Data Field in table AspNetUsers Application OPIDDaily is used by users at Operation ID and by users representing agencies that refer clients to Operation ID. The AgencyId field in table AspNetUsrs will be set to 0 for Operation ID users (for example the TicketMaster user) and will be set to the AgencyId of their referring agency for other users. The AgencyId data field in the Clients table is set in the same way. So, the AgencyId of a client entered into the Clients table at Operation ID on a day of operation will be set to 0. The AgencyId of a client entered by a user representing a referring agency will be set to the AgencyId of the referring agency. Clients are tagged in this way to allow Operation ID users to see all clients and to allow a users from a referring agency to see only the clients referred by that agency. The ServiceDate and Expiry data fields in Table Clients When the TicketMaster adds a new client to the Clients* table the date the client is entered is recorded in the ServiceDate data field of table Clients . The same date is recorded in the Expiry data field. When a Case Manager user enters a new client into the Clients table, the ServiceDate data field is set to the date the client is entered, but the Expiry data field is set at least 30 days into the future. This expiry date will be printed on the Case Manager Voucher given to a client by his/her Case Manager. Application OPIDDaily will preload the Clients** table seen by the TicketMaster with any clients whose Expiry date has not yet past. This will allow a client entered by a Case Manager to be given priority service on the day he/she appears at Operation ID. It is the client's responsibility to appear at Operation ID on or before the expiry date printed on his/her voucher. SessionHelper The SessionHelper class found on fie DAL/SessionHelper.cs is the key method for managing state in application OPIDDaily. This class is used to store key value pairs in the sesssion context private to each authenticated user. Managing the value of NowServing is a key use of the SessionHelper. Instead of having methods called GetNowServing and SetNowServing, the SharedController uses polymorphism to define two methods called NowServing with different signatures. The NowServing method with zero arguments invokes method SessionHelper.Get and the NowServing method with optional argumnt nowServing invokes method SessionHelper.Set. These two NowServing methods are invoked by many methods on SharedController to implement editing functionality private to an autheticated user. The other usage of the SessionHelper class is to manage the the back button helper methods ServiceTicketBackButtonHelper and SpecialReferralBackButtonHelper found on the SharedController. Express Clients and Existing Clients A first time client to Operation ID is referred to as an Express Client. Determining whether a given client is an Express Client is done by consulting the Apricot database to determine whether the client has a visit history . A visit history is a list of services previously performed for a client. If a client is determined to be an Express Client, then a user in the role FrontDesk (a FrontDesk admin) must use the OPIDDaily interface to edit the client and mark him/her as an Express Client. If consulting the Apricot database indicates that a client has a previous service history at Operation ID, then a FrontDesk admin must use the OPIDDaily interface to copy the history of previous visits to the Visits table. This table is related to the Clients table by a foreign key relationship. See the section Entity Framework Code First on the Infrastructure tab for a discussion of this foreign key relationship. Method AddClient of the SharedController receives the id returned by method Clients.AddVisit. This id will be the id of the client inserted into the Clients table. See this StackOverflow article for an explantion of the side effect of record insertion relied upon for this. The client with this id will become the NowServing client. (See the section NowServing.) The foreign key relationship existing between tables Clients and Visits is not supported by a cascading delete; deleting a client from the Clients table does not by default perform a cascading delete of any related records in the Visits table. The cascading delete must be performed manually. To see how this is done, see method RemoveClients in the SuperadminController. A client not marked as an Express Client is referred to as an Existing Client. A FrontDesk admin is responsible for using the interface to distinguish between these two types of client. This has the advantage that a user in the role of Interviewer (an Interviewer admin) need not know the difference. An Interviewer admin prepares Service Tickets (see next section) which automatically include the service history which has been recorded by a FrontDesk admin for Existing Clients. Service Tickets A primary goal of application OPIDDaily is the production of Service Tickets . A service ticket is a single piece of paper that shows the services requested by a given client together with the documents the client is supplying in support of his/her service request. In addition a service ticket provides a history of service requests from previous visits by the client, if any. Service Tickets are produced by an Interviewer Admin. The interviewing process begins by determining the service needs of a client together with documents the client is supplying in support of those needs. An Interviewer admin will use the OPIDDaily interface to capture this information. A client's history of previous visits to Operation ID will have already been recorded by a FrontDesk admin by consulting the Apricot database. After the Service Ticket for a client has been produced, an Interviewer admin will assist the client in filling out paperwork in support of service sought. It is suggested that a client's Service Ticket be forwarded to a BackOffice admin before work on a client's paperwork begins. By passing the Service Ticket to a BackOffice admin, a client's service voucher(s) can be cut and recorded in Apricot while the client is busy with paperwork. In effect a client's BackOffice stage can proceed in parallel with his/her Interviewing stage once the Service Ticket has bee produced. SignalR Application OIDDaily uses version 2.4.1 of the JavaScript SignalR package installed via NuGet. SignalR is a push-technology used to inform authenticated users about the progress of an Operation ID client as he/she passes through the Operation ID pipeline. The SignalR connection hub is defined on file DAL/DailyHub.cs. Invoking a method of DailyHub in the server side code causes a push-notifcation to go out to all clients registered to the hub. For example, when a FrontDesk admin adds a new client to the jqGrid managed by the FrontDeskController, the method SharedController.AddClient will invoke DailyHub.Refresh. A call to the line hubContext.Clients.All.refreshPage(); will send a push notification to all registered clients of the hub. Those clients listening for this notification, for example the view Interviewer/Clients.cshtml, will act upon the notification. In this case, the action will be to refresh the jqGrid of clients displayed by the grid. In this way this grid is kept in synch with the grid to which the client was added by the FrontDesk admin. SignalR is also used by both the special users Client1 and Client2 to refresh the tablet computer displays used by these users. (See the section Managing Users on the Database tab.)","title":"Implementation"},{"location":"Implementation/#implementation","text":"Application OPIDDaily is implemented as an ASP.NET Framework application using the ASP.NET MVC 5 project template provided by Visual Studio 2019 (Community Edition). It uses ASP.NET Identity 2.0 to define a set of user roles. Each user role is associated with a separate MVC controller. Controller inheritance is used to share editing functionality across user roles. It may be useful to upgrade application OPIDDaily to use the more modern ASP.NET Core technology. It may also be useful to proivde an alternative to the free hosting service AppHarbor, which is currentl used by OPIDDaily. See the AppHarbor section of the Infratructure tab for details on this. The graphical user interface of OPIDDaily is built using Bootstrap 3.0.0. Each user role is associated with its own layout file which defines a Bootstrap navbar containing links to the OPIDDaily features available to users in the role. The ASP.NET Identity system ensures that a user in a specified role cannot visit any pages outside of those allowed to users in that role. (See the section on Role Controllers.) Because of its use of SignalR, application OPIDDaily will always require a server side component. See the section on SignalR on this tab for a discussion of this.","title":"Implementation"},{"location":"Implementation/#the-superadmin-user","text":"OPIDDaily defines a pre-registered Superadmin user who has privileges to create new roles invite new users to register in a pre-determined role add new agencies The credentials for the Superadmin user are configured on file Startup.cs. There is only a single user with role of Superadmin.","title":"The Superadmin User"},{"location":"Implementation/#mvc-routing","text":"Application OPIDDaily uses only the default routing rule supplied by the Visual Studio MVC 5 template. This default routing rule is found in .../App_Start/RoutConfig.cs . routes.MapRoute( name: \"Default\", url: \"{controller}/{action}/{id}\", defaults: new { controller = \"Users\", action = \"Index\", id = UrlParameter.Optional } ); For the sake of simplicity, future development of application OPIDDaily should strive to keep this as the one and only routing rule.","title":"MVC Routing"},{"location":"Implementation/#role-controllers","text":"There is an MVC controller defined for each role defined by the superadmin user. Each controller defined for a role inherits from SharedController to implement shared funtionality. The role controllers manage the views of application OPIDDaily. The implementation of each role controller defines methods that are accessible through the menubar defined on the layout file for the role. For example, the FrontDeskController - which implements the FrontDesk role - contains methods ExpressClient and ExistingClient (found on the SharedController) invoked from the menubar defined on file ~/Shared/_FrontDesk.cshtml. This is the layout file for the FrontDesk role. Each view returned by the FrontDeskController includes this layout file, thereby ensuring that a user in the role of FrontDesk will only invoke methods defined by the FrontDeskController. Each other role controllers is implemented the same way: each has a defined layout file that is included in each view returned by the controller. The layout file defines a menubar that specifies the methods that users in the role can invoke. As protection against unauthorized access to methods of a role controller, use of each role controller is limited to users in the role associated with the controller. For example, the FrontDeskController is protected by the annotation [Authorize(Roles = \"FrontDesk\")] Access is then restricted by the functionality of ASP.NET Identity to authenticated users in role FrontDesk.","title":"Role Controllers"},{"location":"Implementation/#the-sharedcontroller","text":"Each role controller derives from SharedController. The SharedController implements the shared editor functionality available to the different roles. Deriving role controllers from a shared controller is an extremely useful technique for building a role-based editor.","title":"The SharedController"},{"location":"Implementation/#the-userscontroller","text":"The UsersController controls access to the ASP.NET Identity tables used to store registered users and the roles they are in. The method UsersController.Index is the entry point for an authenticated user. The role an authenticated user is in determines the method the user will be redirected to from this entry point.","title":"The UsersController"},{"location":"Implementation/#jqgrid","text":"The entire implementation of application OPIDDaily is structured around instances of jqGrid appearing in MVC Views. Each jqGrid is initially populated by a call to an MVC action made through the url property of the grid. For example, the clientsGrid on view FrontDesk/Clients.cshtml is initially populated by the call \"@Url.Action(\"GetClients\", \"FrontDesk)\" which is the value of the url argument to grid clientsGrid. (Method GetClients is found on the SharedController.) Each instance of a jqGride defines a pager , which defines the CRUD operations supported by the grid. Each CRUD operation is implemented by an MVC action of the role controller associated with the grid. Initial population of a grid, grid pagination, grid searching and grid CRUD operations are all supported by server side code. There is a collection of jqGrid Demos that was very helpful during the development of OPIDDaily.","title":"jqGrid"},{"location":"Implementation/#nowserving","text":"An important concept in the implementation of OPIDDaily is the concept of the client currently being served by a registered OPIDDaily user. For example, when a row in the clientsGrid defined on FrontDeskClients.cshtml is selected, the JavaScript function that is the value of the onSelectRow property of the grid is invoked. When the function is invoked, the value passed to its nowServing argument is the id associated with the client represented by the selected row. The function posts to the server side method NowServing of the FrontDeskController (found on SharedController) via the code Url.Action(\"NowServing\", \"FrontDesk\") passing the JavaScript variable nowServing in the post as a result of the line postData: { nowServing: nowServing } Method SharedController/NowServing has an optional argument called nowServing. MVC data binding will cause this variable to be bound to the JavaScript variable in the post.","title":"NowServing"},{"location":"Implementation/#the-agencyid-data-field-in-table-aspnetusers","text":"Application OPIDDaily is used by users at Operation ID and by users representing agencies that refer clients to Operation ID. The AgencyId field in table AspNetUsrs will be set to 0 for Operation ID users (for example the TicketMaster user) and will be set to the AgencyId of their referring agency for other users. The AgencyId data field in the Clients table is set in the same way. So, the AgencyId of a client entered into the Clients table at Operation ID on a day of operation will be set to 0. The AgencyId of a client entered by a user representing a referring agency will be set to the AgencyId of the referring agency. Clients are tagged in this way to allow Operation ID users to see all clients and to allow a users from a referring agency to see only the clients referred by that agency.","title":"The AgencyId Data Field in table AspNetUsers"},{"location":"Implementation/#the-servicedate-and-expiry-data-fields-in-table-clients","text":"When the TicketMaster adds a new client to the Clients* table the date the client is entered is recorded in the ServiceDate data field of table Clients . The same date is recorded in the Expiry data field. When a Case Manager user enters a new client into the Clients table, the ServiceDate data field is set to the date the client is entered, but the Expiry data field is set at least 30 days into the future. This expiry date will be printed on the Case Manager Voucher given to a client by his/her Case Manager. Application OPIDDaily will preload the Clients** table seen by the TicketMaster with any clients whose Expiry date has not yet past. This will allow a client entered by a Case Manager to be given priority service on the day he/she appears at Operation ID. It is the client's responsibility to appear at Operation ID on or before the expiry date printed on his/her voucher.","title":"The ServiceDate and Expiry data fields in Table Clients"},{"location":"Implementation/#sessionhelper","text":"The SessionHelper class found on fie DAL/SessionHelper.cs is the key method for managing state in application OPIDDaily. This class is used to store key value pairs in the sesssion context private to each authenticated user. Managing the value of NowServing is a key use of the SessionHelper. Instead of having methods called GetNowServing and SetNowServing, the SharedController uses polymorphism to define two methods called NowServing with different signatures. The NowServing method with zero arguments invokes method SessionHelper.Get and the NowServing method with optional argumnt nowServing invokes method SessionHelper.Set. These two NowServing methods are invoked by many methods on SharedController to implement editing functionality private to an autheticated user. The other usage of the SessionHelper class is to manage the the back button helper methods ServiceTicketBackButtonHelper and SpecialReferralBackButtonHelper found on the SharedController.","title":"SessionHelper"},{"location":"Implementation/#express-clients-and-existing-clients","text":"A first time client to Operation ID is referred to as an Express Client. Determining whether a given client is an Express Client is done by consulting the Apricot database to determine whether the client has a visit history . A visit history is a list of services previously performed for a client. If a client is determined to be an Express Client, then a user in the role FrontDesk (a FrontDesk admin) must use the OPIDDaily interface to edit the client and mark him/her as an Express Client. If consulting the Apricot database indicates that a client has a previous service history at Operation ID, then a FrontDesk admin must use the OPIDDaily interface to copy the history of previous visits to the Visits table. This table is related to the Clients table by a foreign key relationship. See the section Entity Framework Code First on the Infrastructure tab for a discussion of this foreign key relationship. Method AddClient of the SharedController receives the id returned by method Clients.AddVisit. This id will be the id of the client inserted into the Clients table. See this StackOverflow article for an explantion of the side effect of record insertion relied upon for this. The client with this id will become the NowServing client. (See the section NowServing.) The foreign key relationship existing between tables Clients and Visits is not supported by a cascading delete; deleting a client from the Clients table does not by default perform a cascading delete of any related records in the Visits table. The cascading delete must be performed manually. To see how this is done, see method RemoveClients in the SuperadminController. A client not marked as an Express Client is referred to as an Existing Client. A FrontDesk admin is responsible for using the interface to distinguish between these two types of client. This has the advantage that a user in the role of Interviewer (an Interviewer admin) need not know the difference. An Interviewer admin prepares Service Tickets (see next section) which automatically include the service history which has been recorded by a FrontDesk admin for Existing Clients.","title":"Express Clients and Existing Clients"},{"location":"Implementation/#service-tickets","text":"A primary goal of application OPIDDaily is the production of Service Tickets . A service ticket is a single piece of paper that shows the services requested by a given client together with the documents the client is supplying in support of his/her service request. In addition a service ticket provides a history of service requests from previous visits by the client, if any. Service Tickets are produced by an Interviewer Admin. The interviewing process begins by determining the service needs of a client together with documents the client is supplying in support of those needs. An Interviewer admin will use the OPIDDaily interface to capture this information. A client's history of previous visits to Operation ID will have already been recorded by a FrontDesk admin by consulting the Apricot database. After the Service Ticket for a client has been produced, an Interviewer admin will assist the client in filling out paperwork in support of service sought. It is suggested that a client's Service Ticket be forwarded to a BackOffice admin before work on a client's paperwork begins. By passing the Service Ticket to a BackOffice admin, a client's service voucher(s) can be cut and recorded in Apricot while the client is busy with paperwork. In effect a client's BackOffice stage can proceed in parallel with his/her Interviewing stage once the Service Ticket has bee produced.","title":"Service Tickets"},{"location":"Implementation/#signalr","text":"Application OIDDaily uses version 2.4.1 of the JavaScript SignalR package installed via NuGet. SignalR is a push-technology used to inform authenticated users about the progress of an Operation ID client as he/she passes through the Operation ID pipeline. The SignalR connection hub is defined on file DAL/DailyHub.cs. Invoking a method of DailyHub in the server side code causes a push-notifcation to go out to all clients registered to the hub. For example, when a FrontDesk admin adds a new client to the jqGrid managed by the FrontDeskController, the method SharedController.AddClient will invoke DailyHub.Refresh. A call to the line hubContext.Clients.All.refreshPage(); will send a push notification to all registered clients of the hub. Those clients listening for this notification, for example the view Interviewer/Clients.cshtml, will act upon the notification. In this case, the action will be to refresh the jqGrid of clients displayed by the grid. In this way this grid is kept in synch with the grid to which the client was added by the FrontDesk admin. SignalR is also used by both the special users Client1 and Client2 to refresh the tablet computer displays used by these users. (See the section Managing Users on the Database tab.)","title":"SignalR"},{"location":"Infrastructure/","text":"MkDocs This document was created using MkDocs as was the MkDocs website itself. MkDocs was installed following the guide on this page . This guide is useful for setting up the environment; however, the syntax for the file mkdocs.yml has changed from that described in the guide. The new syntax can be found at in the User Guide section of this document . An MkDocs document is a static website and can hosted by any service that supports static sites. This MkDocs document is hosted by GitHub Pages . The Brackets open source text editor was used to develop the document on the desktop. An MkDocs document uses HTML Markdown for a desktop development version of a document. GitHub provides a cheatsheet for Markdown syntax . MkDocs provides a built-in preview server. To start this server, open a BASH Shell on the folder containing the mkdoc.yml file of the project and execute mkdocs serve Then go to http://127.0.0.1:8000 in a desktop browser. Pages can be edited and saved while in preview mode. The changes will be reflected in the browser document. When it is time to publish a version of a document, in a Git BASH shell opened on the folder containing the mkdocs.yml file, issue the command mkdocs build to expand the Markdown version of the document into an HTML version in the /site folder. Then open the Git GUI on the folder containing the mkdocs.yml file and use the GUI to create a new Git repository on the local disk. Next create repository opiddailydoc to hold the documentation at GitHub. After this, in the folder containing the mkdocs.yml file, define a remote called origin for the document: git remote add origin https://github.com/tmhsplb/opidchecksdoc This command references the GitHub repository opidchecksdoc. The remote only needs to be defined once. It will be remembered by the Git BASH shell. In the shell issue the following commands: git add -A git commit -a -m 'Initial commit' git push origin master This will push the master branch of the document to the repository identified by the remote called origin. Then click on the Settings tab for the newly created repository and scroll down to the GitHub Pages section. Select the master branch source and click on the Save button. Finally, to view the published document go to: https://tmhsplb.github.io/opiddailydoc/site Unless a new file is added to file mkdocs.yml , subsequent edits only require the commands mkdocs build git commit -a -m '<Comment for new commit>' git push origin master to update repository opiddailydoc at GitHub. If a new file is added to mkdocs.yml then git add -A must be run before the mkdocs build command is run. This causes any new files to be added to the local git repository. In either case it may take several minutes before edits are available.","title":"Infrastructure"},{"location":"Infrastructure/#mkdocs","text":"This document was created using MkDocs as was the MkDocs website itself. MkDocs was installed following the guide on this page . This guide is useful for setting up the environment; however, the syntax for the file mkdocs.yml has changed from that described in the guide. The new syntax can be found at in the User Guide section of this document . An MkDocs document is a static website and can hosted by any service that supports static sites. This MkDocs document is hosted by GitHub Pages . The Brackets open source text editor was used to develop the document on the desktop. An MkDocs document uses HTML Markdown for a desktop development version of a document. GitHub provides a cheatsheet for Markdown syntax . MkDocs provides a built-in preview server. To start this server, open a BASH Shell on the folder containing the mkdoc.yml file of the project and execute mkdocs serve Then go to http://127.0.0.1:8000 in a desktop browser. Pages can be edited and saved while in preview mode. The changes will be reflected in the browser document. When it is time to publish a version of a document, in a Git BASH shell opened on the folder containing the mkdocs.yml file, issue the command mkdocs build to expand the Markdown version of the document into an HTML version in the /site folder. Then open the Git GUI on the folder containing the mkdocs.yml file and use the GUI to create a new Git repository on the local disk. Next create repository opiddailydoc to hold the documentation at GitHub. After this, in the folder containing the mkdocs.yml file, define a remote called origin for the document: git remote add origin https://github.com/tmhsplb/opidchecksdoc This command references the GitHub repository opidchecksdoc. The remote only needs to be defined once. It will be remembered by the Git BASH shell. In the shell issue the following commands: git add -A git commit -a -m 'Initial commit' git push origin master This will push the master branch of the document to the repository identified by the remote called origin. Then click on the Settings tab for the newly created repository and scroll down to the GitHub Pages section. Select the master branch source and click on the Save button. Finally, to view the published document go to: https://tmhsplb.github.io/opiddailydoc/site Unless a new file is added to file mkdocs.yml , subsequent edits only require the commands mkdocs build git commit -a -m '<Comment for new commit>' git push origin master to update repository opiddailydoc at GitHub. If a new file is added to mkdocs.yml then git add -A must be run before the mkdocs build command is run. This causes any new files to be added to the local git repository. In either case it may take several minutes before edits are available.","title":"MkDocs"}]}